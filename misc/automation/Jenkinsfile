
pipeline {
  agent any
  environment  {
    APP_NAME = credentials('APP_NAME')
    APP_ENV = credentials('APP_ENV')
    APP_KEY = credentials('APP_KEY')
    APP_DEBUG = credentials('APP_DEBUG')
    APP_TIMEZONE = credentials('APP_TIMEZONE')

    APP_LOCALE = credentials('APP_LOCALE')
    APP_FALLBACK_LOCALE = credentials('APP_FALLBACK_LOCALE')
    APP_FAKER_LOCALE = credentials('APP_FAKER_LOCALE')

    BCRYPT_ROUNDS = credentials('BCRYPT_ROUNDS')

    LOG_CHANNEL = credentials('LOG_CHANNEL')
    LOG_STACK = credentials('LOG_STACK')
    LOG_DEPRECATIONS_CHANNEL = credentials('LOG_DEPRECATIONS_CHANNEL')
    LOG_LEVEL = credentials('LOG_LEVEL')

    DB_CONNECTION = credentials('DB_CONNECTION')
    DB_HOST = credentials('DB_HOST')
    DB_PORT = credentials('DB_PORT')
    DB_DATABASE = credentials('DB_DATABASE')
    DB_USERNAME = credentials('DB_USERNAME')
    DB_PASSWORD = credentials('DB_PASSWORD')

    SESSION_DRIVER = credentials('SESSION_DRIVER')
    SESSION_LIFETIME = credentials('SESSION_LIFETIME')
    SESSION_ENCRYPT = credentials('SESSION_ENCRYPT')
    SESSION_PATH = credentials('SESSION_PATH')
    SESSION_DOMAIN = credentials('SESSION_DOMAIN')

    BROADCAST_CONNECTION = credentials('BROADCAST_CONNECTION')
    FILESYSTEM_DISK = credentials('FILESYSTEM_DISK')
    QUEUE_CONNECTION = credentials('QUEUE_CONNECTION')
    
    CACHE_STORE = credentials('CACHE_STORE')
    CACHE_PREFIX = credentials('CACHE_PREFIX')

    MEMCACHED_HOST = credentials('MEMCACHED_HOST')

    REDIS_CLIENT = credentials('REDIS_CLIENT')
    REDIS_HOST = credentials('REDIS_HOST')
    REDIS_PASSWORD = credentials('REDIS_PASSWORD')
    REDIST_PORT = credentials('REDIST_PORT')

    MAIL_MAILER = credentials('MAIL_MAILER')
    MAIL_HOST = credentials('MAIL_HOST')
    MAIL_PORT = credentials('MAIL_PORT')
    MAIL_USERNAME = credentials('MAIL_USERNAME')
    MAIL_PASSWORD = credentials('MAIL_PASSWORD')
    MAIL_ENCRYPTION = credentials('MAIL_ENCRYPTION')
    MAIL_FROM_ADDRESS = credentials('MAIL_FROM_ADDRESS')
    MAIL_FROM_NAME = credentials('MAIL_FROM_NAME')
    
    AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
    AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
    AWS_DEFAULT_REGION = credentials('AWS_DEFAULT_REGION')
    AWS_BUCKET = credentials('AWS_BUCKET')
    AWS_USE_PATH_STYLE_ENDPOINT = credentials('AWS_USE_PATH_STYLE_ENDPOINT')
    
    VITE_APP_NAME = credentials('VITE_APP_NAME')

    JWT_SECRET = credentials('JWT_SECRET')
    JWT_ALGO = credentials('JWT_ALGO')
    JWT_SHOW_BLACKLIST_EXCEPTION = credentials('JWT_SHOW_BLACKLIST_EXCEPTION')
  }
  stages {
    stage("BUILD DOCKER IMAGE") {
            when {
                expression {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine whether to execute the stage based on the branch name
                    return branchName == env.GIT_PRODUCTION_BRANCH || branchName == env.GIT_STAGING_BRANCH
                }
            }
            steps {
                script {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine the appropriate image tags based on the branch name
                    def imageTags = branchName == env.GIT_PRODUCTION_BRANCH ? "${IMAGE_TAGS_PRODUCTION}" : "${IMAGE_TAGS_STAGING}"

                    echo "========BUILD DOCKER IMAGE FROM BRANCH ${branchName.toUpperCase()}========"
                    sh "docker build -f ./misc/docker/Dockerfile --label ${CONTAINER_LABEL} -t $REGISTRY_IMAGE_STARTER_NAME/${IMAGE_NAME}:${imageTags} ."
                }
            }
        }
        stage("PUSH IMAGE TO REGISTRY"){
            when {
                expression {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine whether to execute the stage based on the branch name
                    return branchName == env.GIT_PRODUCTION_BRANCH || branchName == env.GIT_STAGING_BRANCH
                }
            }
            steps{
                script {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine the appropriate image tags based on the branch name
                    def imageTags = branchName == env.GIT_PRODUCTION_BRANCH ? "${IMAGE_TAGS_PRODUCTION}" : "${IMAGE_TAGS_STAGING}"

                    echo "========PUSH DOCKER IMAGE TO REGISTRY FROM BRANCH ${branchName.toUpperCase()}========"
                    sh "echo $REGISTRY_CREDENTIALS_PSW | docker login -u $REGISTRY_CREDENTIALS_USR --password-stdin $REGISTRY_ADDRESS"
                    sh "docker push $REGISTRY_IMAGE_STARTER_NAME/${IMAGE_NAME}:${imageTags}"
                }

            }
        }
        stage("CLEAN UP LOCAL IMAGE") {
            when {
                expression {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine whether to execute the stage based on the branch name
                    return branchName == env.GIT_PRODUCTION_BRANCH || branchName == env.GIT_STAGING_BRANCH
                }
            }
            steps {
                script {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine the appropriate image tags based on the branch name
                    def imageTags = branchName == env.GIT_PRODUCTION_BRANCH ? "${IMAGE_TAGS_PRODUCTION}" : "${IMAGE_TAGS_STAGING}"
                    echo "========CLEAN UP LOCAL IMAGE FROM BRANCH ${branchName.toUpperCase()}========"
                    sh "docker rmi $REGISTRY_IMAGE_STARTER_NAME/${IMAGE_NAME}:${imageTags}"
                }

            }
        }
        stage("DEPLOY TO SERVER") {
            when {
                expression {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine whether to execute the stage based on the branch name
                    return branchName == env.GIT_PRODUCTION_BRANCH || branchName == env.GIT_STAGING_BRANCH
                }
            }
            steps {
                script {
                    // Get the current branch name
                    def branchName = env.BRANCH_NAME

                    // Determine the appropriate image tags based on the branch name
                    def imageTags = branchName == env.GIT_PRODUCTION_BRANCH ? "${IMAGE_TAGS_PRODUCTION}" : "${IMAGE_TAGS_STAGING}"
                    def containerName = branchName == env.GIT_PRODUCTION_BRANCH ? "${CONTAINER_PRODUCTION_NAME}" : "${CONTAINER_STAGING_NAME}"
                        echo "========DEPLOY TO PRODUCTION SERVER FROM BRANCH ${branchName.toUpperCase()}========"
                        sshagent(['ssh-noc-ct-122-api']) {
                            sh "ssh ${REMOTE_USER}@${REMOTE_SERVER} 'echo $REGISTRY_CREDENTIALS_PSW | docker login -u $REGISTRY_CREDENTIALS_USR --password-stdin $REGISTRY_ADDRESS'"
                            sh "ssh ${REMOTE_USER}@${REMOTE_SERVER} 'docker container rm -f ${containerName} || true'"
                            sh "ssh ${REMOTE_USER}@${REMOTE_SERVER} 'docker pull $REGISTRY_IMAGE_STARTER_NAME/${IMAGE_NAME}:${imageTags}'"
                            sh "ssh ${REMOTE_USER}@${REMOTE_SERVER} 'docker image prune --filter 'label=${CONTAINER_LABEL}' -f'"
                            sh "ssh ${REMOTE_USER}@${REMOTE_SERVER} 'docker run -d --name ${containerName} -p ${PRODUCTION_PORT}:80 \
                            --restart=always \
                            --network nginx-network \
                            -v /home/key_api:/home/key_api \
                            -e APP_NAME=${APP_NAME} \
                            -e APP_ENV=${APP_ENV} \
                            -e APP_KEY=${APP_KEY} \
                            -e APP_DEBUG=${APP_DEBUG} \
                            -e APP_URL=${APP_URL} \
                            -e APP_TIMEZONE=${APP_TIMEZONE} \
                            -e AUTH_GUARD=${AUTH_GUARD} \
                            -e JWT_PUBLIC_KEY=${JWT_PUBLIC_KEY} \
                            -e JWT_VERIFY=true \
                            -e DB_CONNECTION=${DB_CONNECTION} \
                            -e DB_HOST=${DB_HOST} \
                            -e DB_PORT=${DB_PORT} \
                            -e DB_DATABASE=${DB_DATABASE} \
                            -e DB_USERNAME=${DB_USERNAME} \
                            -e DB_PASSWORD=${DB_PASSWORD} \
                            -e ILAB_API_URL=${ILAB_API_URL} \
                            -e REDIS_HOST=${REDIS_HOST} \
                            -e REDIS_PASSWORD=${REDIS_PASSWORD} \
                            -e REDIS_PORT=${REDIS_PORT} \
                            -e RABBITMQ_QUEUE=${RABBITMQ_QUEUE} \
                            -e RABBITMQ_HOST=${RABBITMQ_HOST} \
                            -e RABBITMQ_PORT=${RABBITMQ_PORT} \
                            -e RABBITMQ_USER=${RABBITMQ_USER} \
                            -e RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD} \
                            -e AWS_ENDPOINT=${AWS_ENDPOINT} \
                            -e AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} \
                            -e AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} \
                            -e AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION} \
                            -e AWS_BUCKET=${AWS_BUCKET} \
                            -e AWS_BUCKET_DEV=${AWS_BUCKET_DEV} \
                            -e AWS_URL=${AWS_URL} \
                            $REGISTRY_IMAGE_STARTER_NAME/${IMAGE_NAME}:${imageTags}'"
                            sh "ssh ${REMOTE_USER}@${REMOTE_SERVER} 'docker logout $REGISTRY_ADDRESS'"
                        }
                    }
                }
            }
        }
    }
    post{
      always{
          echo "========always========"
          sh 'docker logout $REGISTRY_ADDRESS'
      }
  }
